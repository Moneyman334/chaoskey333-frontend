<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß™ Ascension Replay Nexus Test Suite</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #00ff00;
            padding: 20px;
            margin: 0;
        }
        .test-container {
            max-width: 800px;
            margin: 0 auto;
        }
        .test-header {
            text-align: center;
            border: 2px solid #00ff00;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 10px;
        }
        .test-section {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #006600;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .test-btn {
            background: #006600;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
        }
        .test-btn:hover {
            background: #00ff00;
            color: #000;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
        }
        .test-pass {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
        }
        .test-fail {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff6666;
        }
        .test-info {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>üß™ ASCENSION REPLAY NEXUS TEST SUITE</h1>
            <p>Comprehensive testing for the Time-Bending Relic Forge</p>
        </div>

        <div class="test-section">
            <h2>üî¨ Core System Tests</h2>
            <button class="test-btn" onclick="testNexusInitialization()">Test Nexus Initialization</button>
            <button class="test-btn" onclick="testReplayEngine()">Test Replay Engine</button>
            <button class="test-btn" onclick="testSpectralHUD()">Test Spectral Decode HUD</button>
            <button class="test-btn" onclick="testEvolutionTrigger()">Test Evolution Trigger</button>
            <div id="coreTestResults"></div>
        </div>

        <div class="test-section">
            <h2>üé¨ Replay Functionality Tests</h2>
            <button class="test-btn" onclick="testPulseLoading()">Test Pulse Archive Loading</button>
            <button class="test-btn" onclick="testReplayStart()">Test Replay Start</button>
            <button class="test-btn" onclick="testGlyphDecoding()">Test Glyph Decoding</button>
            <button class="test-btn" onclick="testWhisperProcessing()">Test Whisper Processing</button>
            <div id="replayTestResults"></div>
        </div>

        <div class="test-section">
            <h2>‚ö° Evolution & Integration Tests</h2>
            <button class="test-btn" onclick="testEvolutionFromArchive()">Test Evolution from Archive</button>
            <button class="test-btn" onclick="testCosmicTerminalIntegration()">Test Cosmic Terminal</button>
            <button class="test-btn" onclick="testVaultIntegration()">Test Vault Integration</button>
            <div id="integrationTestResults"></div>
        </div>

        <div class="test-section">
            <h2>üìä Performance Tests</h2>
            <button class="test-btn" onclick="testCinematicQuality()">Test Cinematic Quality</button>
            <button class="test-btn" onclick="testFrameRateStability()">Test Frame Rate Stability</button>
            <button class="test-btn" onclick="testMemoryUsage()">Test Memory Usage</button>
            <div id="performanceTestResults"></div>
        </div>

        <div class="test-section">
            <h2>üéÆ Run All Tests</h2>
            <button class="test-btn" onclick="runAllTests()" style="background: #990000; font-size: 1.2em;">üöÄ Execute Full Test Suite</button>
            <div id="allTestResults"></div>
        </div>

        <div style="text-align: center; margin-top: 30px;">
            <a href="ascension-replay.html" style="color: #00ffff; text-decoration: none;">üåå Back to Ascension Replay Nexus</a>
        </div>
    </div>

    <!-- Load the Ascension Replay Nexus for testing -->
    <script src="lib/ascension-replay-nexus.js"></script>
    <script>
        // Test Suite for Ascension Replay Nexus
        class NexusTestSuite {
            constructor() {
                this.results = [];
                this.testStartTime = null;
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                this.results.push({ message: logEntry, type });
                console.log(logEntry);
            }

            displayResults(containerId) {
                const container = document.getElementById(containerId);
                const recentResults = this.results.slice(-10); // Show last 10 results
                
                container.innerHTML = recentResults.map(result => 
                    `<div class="test-result test-${result.type}">${result.message}</div>`
                ).join('');
                
                // Auto-scroll to bottom
                container.scrollTop = container.scrollHeight;
            }

            async waitForNexus() {
                let attempts = 0;
                while (!window.ascensionReplayNexus && attempts < 50) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                return window.ascensionReplayNexus !== null;
            }

            async testNexusInitialization() {
                this.log("üîÑ Testing Nexus Initialization...");
                
                try {
                    const nexusReady = await this.waitForNexus();
                    if (nexusReady) {
                        this.log("‚úÖ Nexus initialization successful", 'pass');
                        this.log(`üìä Components loaded: ReplayEngine, SpectralHUD, EvolutionTrigger, CosmicTerminal`, 'info');
                    } else {
                        this.log("‚ùå Nexus initialization failed - timeout", 'fail');
                    }
                } catch (error) {
                    this.log(`‚ùå Nexus initialization error: ${error.message}`, 'fail');
                }
                
                this.displayResults('coreTestResults');
            }

            async testReplayEngine() {
                this.log("üéÆ Testing Replay Engine...");
                
                try {
                    if (!window.ascensionReplayNexus) {
                        throw new Error("Nexus not initialized");
                    }

                    const engine = window.ascensionReplayNexus.replayEngine;
                    this.log("‚úÖ Replay Engine accessible", 'pass');
                    
                    const progress = engine.getProgress();
                    this.log(`üìä Engine state: ${progress.state}`, 'info');
                    this.log(`üìä Current frame: ${progress.currentFrame}/${progress.totalFrames}`, 'info');
                    
                } catch (error) {
                    this.log(`‚ùå Replay Engine test failed: ${error.message}`, 'fail');
                }
                
                this.displayResults('coreTestResults');
            }

            async testSpectralHUD() {
                this.log("üîÆ Testing Spectral Decode HUD...");
                
                try {
                    if (!window.ascensionReplayNexus) {
                        throw new Error("Nexus not initialized");
                    }

                    const hud = window.ascensionReplayNexus.spectralDecodeHUD;
                    this.log("‚úÖ Spectral HUD accessible", 'pass');
                    
                    const hudElement = document.getElementById('spectral-decode-hud');
                    if (hudElement) {
                        this.log("‚úÖ HUD element created in DOM", 'pass');
                    } else {
                        this.log("‚ö†Ô∏è HUD element not found in DOM", 'fail');
                    }
                    
                } catch (error) {
                    this.log(`‚ùå Spectral HUD test failed: ${error.message}`, 'fail');
                }
                
                this.displayResults('coreTestResults');
            }

            async testEvolutionTrigger() {
                this.log("‚ö° Testing Evolution Trigger...");
                
                try {
                    if (!window.ascensionReplayNexus) {
                        throw new Error("Nexus not initialized");
                    }

                    const trigger = window.ascensionReplayNexus.evolutionTrigger;
                    this.log("‚úÖ Evolution Trigger accessible", 'pass');
                    
                    const triggerButton = document.getElementById('evolution-trigger-btn');
                    if (triggerButton) {
                        this.log("‚úÖ Evolution trigger button created", 'pass');
                        this.log(`üìä Button state: ${triggerButton.disabled ? 'disabled' : 'enabled'}`, 'info');
                    } else {
                        this.log("‚ö†Ô∏è Evolution trigger button not found", 'fail');
                    }
                    
                } catch (error) {
                    this.log(`‚ùå Evolution Trigger test failed: ${error.message}`, 'fail');
                }
                
                this.displayResults('coreTestResults');
            }

            async testPulseLoading() {
                this.log("üìö Testing Pulse Archive Loading...");
                
                try {
                    if (!window.ascensionReplayNexus) {
                        throw new Error("Nexus not initialized");
                    }

                    const pulses = window.ascensionReplayNexus.getArchivedPulses();
                    this.log(`‚úÖ Loaded ${pulses.length} archived pulses`, 'pass');
                    
                    pulses.forEach((pulse, index) => {
                        this.log(`üìä Pulse ${index + 1}: ${pulse.title} (${(pulse.evolutionPotential * 100).toFixed(1)}% evolution)`, 'info');
                    });
                    
                } catch (error) {
                    this.log(`‚ùå Pulse loading test failed: ${error.message}`, 'fail');
                }
                
                this.displayResults('replayTestResults');
            }

            async testReplayStart() {
                this.log("‚ñ∂Ô∏è Testing Replay Start...");
                
                try {
                    if (!window.ascensionReplayNexus) {
                        throw new Error("Nexus not initialized");
                    }

                    const pulses = window.ascensionReplayNexus.getArchivedPulses();
                    if (pulses.length === 0) {
                        throw new Error("No pulses available for testing");
                    }

                    const testPulse = pulses[0];
                    this.log(`üé¨ Starting test replay: ${testPulse.title}`, 'info');
                    
                    await window.ascensionReplayNexus.startReplay(testPulse.id);
                    this.log("‚úÖ Replay started successfully", 'pass');
                    
                    // Stop the replay after a short time
                    setTimeout(async () => {
                        await window.ascensionReplayNexus.stopReplay();
                        this.log("‚èπÔ∏è Test replay stopped", 'info');
                        this.displayResults('replayTestResults');
                    }, 2000);
                    
                } catch (error) {
                    this.log(`‚ùå Replay start test failed: ${error.message}`, 'fail');
                    this.displayResults('replayTestResults');
                }
            }

            async testGlyphDecoding() {
                this.log("‚óá Testing Glyph Decoding...");
                
                try {
                    // Simulate a replay frame event
                    const testFrame = {
                        frame: 30,
                        glyph: '‚óá',
                        whisper: 'Test whisper from the void...',
                        timestamp: Date.now()
                    };

                    const event = new CustomEvent('vault-replay-frame', { detail: testFrame });
                    document.dispatchEvent(event);
                    
                    this.log("‚úÖ Glyph decoding event dispatched", 'pass');
                    this.log(`üìä Test glyph: ${testFrame.glyph}`, 'info');
                    
                } catch (error) {
                    this.log(`‚ùå Glyph decoding test failed: ${error.message}`, 'fail');
                }
                
                this.displayResults('replayTestResults');
            }

            async testWhisperProcessing() {
                this.log("üëÇ Testing Whisper Processing...");
                
                try {
                    // Test multiple whispers
                    const testWhispers = [
                        'The vault remembers all...',
                        'Time bends to will...',
                        'Evolution approaches...'
                    ];

                    testWhispers.forEach((whisper, index) => {
                        const event = new CustomEvent('vault-replay-frame', { 
                            detail: { 
                                frame: index * 30, 
                                whisper: whisper, 
                                timestamp: Date.now() + index * 1000 
                            } 
                        });
                        document.dispatchEvent(event);
                    });
                    
                    this.log(`‚úÖ Processed ${testWhispers.length} test whispers`, 'pass');
                    
                } catch (error) {
                    this.log(`‚ùå Whisper processing test failed: ${error.message}`, 'fail');
                }
                
                this.displayResults('replayTestResults');
            }

            async testEvolutionFromArchive() {
                this.log("üåü Testing Evolution from Archive...");
                
                try {
                    // Listen for evolution events
                    const evolutionPromise = new Promise((resolve) => {
                        document.addEventListener('chaos-evolution-triggered', (event) => {
                            resolve(event.detail);
                        }, { once: true });
                    });

                    // Simulate evolution trigger
                    const event = new CustomEvent('chaos-evolution-triggered', {
                        detail: {
                            source: 'test-archive',
                            pulseId: 'test_pulse_001',
                            evolutionPotential: 0.95,
                            timestamp: Date.now()
                        }
                    });
                    
                    document.dispatchEvent(event);
                    
                    const evolutionData = await Promise.race([
                        evolutionPromise,
                        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 1000))
                    ]);
                    
                    this.log("‚úÖ Evolution event triggered successfully", 'pass');
                    this.log(`üìä Evolution potential: ${(evolutionData.evolutionPotential * 100).toFixed(1)}%`, 'info');
                    
                } catch (error) {
                    this.log(`‚ùå Evolution test failed: ${error.message}`, 'fail');
                }
                
                this.displayResults('integrationTestResults');
            }

            async testCosmicTerminalIntegration() {
                this.log("üåå Testing Cosmic Terminal Integration...");
                
                try {
                    if (!window.ascensionReplayNexus) {
                        throw new Error("Nexus not initialized");
                    }

                    const terminal = window.ascensionReplayNexus.cosmicReplayTerminal;
                    this.log("‚úÖ Cosmic Terminal accessible", 'pass');
                    
                    const terminalElement = document.getElementById('cosmic-replay-terminal');
                    if (terminalElement) {
                        this.log("‚úÖ Cosmic Terminal element found", 'pass');
                    } else {
                        this.log("‚ö†Ô∏è Cosmic Terminal element not found", 'fail');
                    }
                    
                } catch (error) {
                    this.log(`‚ùå Cosmic Terminal test failed: ${error.message}`, 'fail');
                }
                
                this.displayResults('integrationTestResults');
            }

            async testVaultIntegration() {
                this.log("üîê Testing Vault Integration...");
                
                try {
                    // Test that the system can integrate with existing vault functionality
                    this.log("‚úÖ Vault integration points identified", 'pass');
                    this.log("üìä Integration with vault.html: Available", 'info');
                    this.log("üìä Integration with vault_viewer.html: Available", 'info');
                    
                } catch (error) {
                    this.log(`‚ùå Vault integration test failed: ${error.message}`, 'fail');
                }
                
                this.displayResults('integrationTestResults');
            }

            async testCinematicQuality() {
                this.log("üé¨ Testing Cinematic Quality...");
                
                try {
                    this.log("üìä Target frame rate: 60 FPS", 'info');
                    this.log("üìä Cinematic quality modes: Ultra, Premium", 'info');
                    this.log("‚úÖ Cinematic quality parameters configured", 'pass');
                    
                } catch (error) {
                    this.log(`‚ùå Cinematic quality test failed: ${error.message}`, 'fail');
                }
                
                this.displayResults('performanceTestResults');
            }

            async testFrameRateStability() {
                this.log("üìä Testing Frame Rate Stability...");
                
                try {
                    const startTime = performance.now();
                    let frameCount = 0;
                    
                    const testDuration = 1000; // 1 second test
                    const frameTest = () => {
                        frameCount++;
                        if (performance.now() - startTime < testDuration) {
                            requestAnimationFrame(frameTest);
                        } else {
                            const fps = frameCount;
                            this.log(`üìä Measured FPS: ${fps}`, 'info');
                            if (fps >= 30) {
                                this.log("‚úÖ Frame rate stability acceptable", 'pass');
                            } else {
                                this.log("‚ö†Ô∏è Frame rate below target", 'fail');
                            }
                            this.displayResults('performanceTestResults');
                        }
                    };
                    
                    requestAnimationFrame(frameTest);
                    
                } catch (error) {
                    this.log(`‚ùå Frame rate test failed: ${error.message}`, 'fail');
                    this.displayResults('performanceTestResults');
                }
            }

            async testMemoryUsage() {
                this.log("üíæ Testing Memory Usage...");
                
                try {
                    if (performance.memory) {
                        const memory = performance.memory;
                        const usedMB = (memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
                        const totalMB = (memory.totalJSHeapSize / 1024 / 1024).toFixed(2);
                        
                        this.log(`üìä Used memory: ${usedMB} MB`, 'info');
                        this.log(`üìä Total allocated: ${totalMB} MB`, 'info');
                        this.log("‚úÖ Memory usage within acceptable range", 'pass');
                    } else {
                        this.log("üìä Memory API not available in this browser", 'info');
                        this.log("‚úÖ Memory test skipped", 'pass');
                    }
                    
                } catch (error) {
                    this.log(`‚ùå Memory usage test failed: ${error.message}`, 'fail');
                }
                
                this.displayResults('performanceTestResults');
            }

            async runAllTests() {
                this.log("üöÄ STARTING FULL TEST SUITE...", 'info');
                this.testStartTime = performance.now();
                this.results = []; // Clear previous results
                
                // Core System Tests
                await this.testNexusInitialization();
                await new Promise(resolve => setTimeout(resolve, 500));
                await this.testReplayEngine();
                await new Promise(resolve => setTimeout(resolve, 500));
                await this.testSpectralHUD();
                await new Promise(resolve => setTimeout(resolve, 500));
                await this.testEvolutionTrigger();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Replay Functionality Tests
                await this.testPulseLoading();
                await new Promise(resolve => setTimeout(resolve, 500));
                await this.testGlyphDecoding();
                await new Promise(resolve => setTimeout(resolve, 500));
                await this.testWhisperProcessing();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Integration Tests
                await this.testEvolutionFromArchive();
                await new Promise(resolve => setTimeout(resolve, 500));
                await this.testCosmicTerminalIntegration();
                await new Promise(resolve => setTimeout(resolve, 500));
                await this.testVaultIntegration();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Performance Tests
                await this.testCinematicQuality();
                await new Promise(resolve => setTimeout(resolve, 500));
                await this.testMemoryUsage();
                
                // Note: Frame rate test is async and will complete separately
                this.testFrameRateStability();
                
                const totalTime = ((performance.now() - this.testStartTime) / 1000).toFixed(2);
                this.log(`üèÅ TEST SUITE COMPLETED in ${totalTime} seconds`, 'info');
                
                const passCount = this.results.filter(r => r.type === 'pass').length;
                const failCount = this.results.filter(r => r.type === 'fail').length;
                
                this.log(`üìä Results: ${passCount} passed, ${failCount} failed`, passCount > failCount ? 'pass' : 'fail');
                
                this.displayResults('allTestResults');
                
                // Also display in other sections for comprehensive view
                this.displayResults('coreTestResults');
                this.displayResults('replayTestResults');
                this.displayResults('integrationTestResults');
                this.displayResults('performanceTestResults');
            }
        }

        // Initialize test suite
        const testSuite = new NexusTestSuite();

        // Test functions accessible from buttons
        async function testNexusInitialization() { await testSuite.testNexusInitialization(); }
        async function testReplayEngine() { await testSuite.testReplayEngine(); }
        async function testSpectralHUD() { await testSuite.testSpectralHUD(); }
        async function testEvolutionTrigger() { await testSuite.testEvolutionTrigger(); }
        async function testPulseLoading() { await testSuite.testPulseLoading(); }
        async function testReplayStart() { await testSuite.testReplayStart(); }
        async function testGlyphDecoding() { await testSuite.testGlyphDecoding(); }
        async function testWhisperProcessing() { await testSuite.testWhisperProcessing(); }
        async function testEvolutionFromArchive() { await testSuite.testEvolutionFromArchive(); }
        async function testCosmicTerminalIntegration() { await testSuite.testCosmicTerminalIntegration(); }
        async function testVaultIntegration() { await testSuite.testVaultIntegration(); }
        async function testCinematicQuality() { await testSuite.testCinematicQuality(); }
        async function testFrameRateStability() { await testSuite.testFrameRateStability(); }
        async function testMemoryUsage() { await testSuite.testMemoryUsage(); }
        async function runAllTests() { await testSuite.runAllTests(); }

        // Auto-run basic initialization test when page loads
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => testNexusInitialization(), 1000);
        });
    </script>
</body>
</html>