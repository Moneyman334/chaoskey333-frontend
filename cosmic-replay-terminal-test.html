<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåå Cosmic Replay Terminal v2.0 - Test Environment</title>
    <style>
        body { 
            font-family: 'Courier New', monospace; 
            padding: 20px; 
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0033 50%, #0a0a0a 100%); 
            color: #00ff00; 
            margin: 0;
            min-height: 100vh;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { 
            text-align: center; 
            margin-bottom: 30px; 
            border: 2px solid #00ff00; 
            padding: 20px; 
            background: rgba(0, 255, 0, 0.1);
            border-radius: 10px;
        }
        .header h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 0 0 20px #00ff00;
        }
        .test-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); 
            gap: 20px; 
            margin-bottom: 20px;
        }
        .test-section { 
            border: 1px solid #333; 
            border-radius: 8px; 
            padding: 20px; 
            background: linear-gradient(145deg, #111, #1a1a1a); 
            position: relative;
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.1);
        }
        .test-section h3 { 
            color: #00ff00; 
            margin-top: 0; 
            border-bottom: 1px solid #333; 
            padding-bottom: 10px;
            display: flex;
            align-items: center;
        }
        .test-section h3::before {
            content: "üîÆ";
            margin-right: 10px;
        }
        .status { 
            padding: 15px; 
            margin: 15px 0; 
            border-radius: 5px; 
            border-left: 4px solid;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .success { background: rgba(0, 255, 0, 0.2); border-color: #00ff00; color: #00ff00; }
        .error { background: rgba(255, 0, 0, 0.2); border-color: #ff0000; color: #ff6666; }
        .warning { background: rgba(255, 255, 0, 0.2); border-color: #ffff00; color: #ffff66; }
        .info { background: rgba(0, 102, 255, 0.2); border-color: #0066ff; color: #6666ff; }
        .loading { background: rgba(255, 0, 255, 0.2); border-color: #ff00ff; color: #ff66ff; }
        
        button { 
            padding: 12px 20px; 
            margin: 8px; 
            background: linear-gradient(145deg, #006600, #004d00); 
            color: #00ff00; 
            border: 1px solid #00ff00; 
            border-radius: 5px; 
            cursor: pointer; 
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0, 255, 0, 0.3);
        }
        button:hover { 
            background: linear-gradient(145deg, #00ff00, #00cc00); 
            color: #000; 
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.6);
        }
        button:disabled { 
            background: #333; 
            color: #666; 
            cursor: not-allowed; 
            box-shadow: none;
        }
        
        .capsule-display {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-size: 0.9em;
        }
        
        .capsule-display h4 {
            color: #00ffff;
            margin: 0 0 10px 0;
        }
        
        .format-verification {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        
        .format-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #555;
            border-radius: 5px;
            padding: 10px;
            text-align: center;
        }
        
        .format-box.valid {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }
        
        .format-box.invalid {
            border-color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
        }
        
        .pulse-id {
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
        }
        
        .cosmic-energy {
            color: #ff00ff;
            font-weight: bold;
        }
        
        .feed-display {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
        }
        
        .feed-item {
            border-bottom: 1px solid #222;
            padding: 10px 0;
            margin-bottom: 10px;
        }
        
        .feed-item:last-child {
            border-bottom: none;
        }
        
        .auto-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 15px 0;
        }
        
        .interval-input {
            padding: 8px;
            background: #222;
            border: 1px solid #555;
            color: #00ff00;
            border-radius: 3px;
            width: 80px;
        }
        
        .master-control {
            grid-column: 1 / -1;
            text-align: center;
            background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
            border: 2px solid #00ff00;
        }
        
        .master-control button {
            font-size: 18px;
            padding: 20px 40px;
            background: linear-gradient(145deg, #ff6600, #ff4400);
            color: white;
            border: 2px solid #ff6600;
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.5);
        }
        
        .master-control button:hover {
            background: linear-gradient(145deg, #ff8800, #ff6600);
            box-shadow: 0 0 30px rgba(255, 102, 0, 0.8);
        }

        .real-time-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            background: #00ff00;
            border-radius: 50%;
            margin-right: 5px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }

        .cosmic-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.1;
            background: 
                radial-gradient(circle at 20% 80%, #ff00ff 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, #00ffff 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, #ffff00 0%, transparent 50%);
            animation: cosmicShift 20s ease-in-out infinite;
        }

        @keyframes cosmicShift {
            0%, 100% { transform: translateX(0px) translateY(0px); }
            33% { transform: translateX(30px) translateY(-30px); }
            66% { transform: translateX(-20px) translateY(20px); }
        }
    </style>
</head>
<body>
    <div class="cosmic-background"></div>
    
    <div class="container">
        <div class="header">
            <h1>üåå COSMIC REPLAY TERMINAL v2.0 üåå</h1>
            <p>Test Environment for Replay Capsule Generation & Vault Feed Integration</p>
            <div class="real-time-indicator"></div>
            <span>Live Terminal Status</span>
        </div>
        
        <div class="test-grid">
            <!-- Terminal Initialization -->
            <div class="test-section">
                <h3>Initialization & Hooks</h3>
                <div id="initStatus" class="status info">üöÄ Ready to initialize Cosmic Replay Terminal v2.0...</div>
                <button onclick="initializeTerminal()">Initialize Terminal</button>
                <button onclick="getTerminalStatus()">Check Status</button>
                <button onclick="testHooksOperational()">Test Hooks</button>
            </div>

            <!-- Capsule Generation -->
            <div class="test-section">
                <h3>Replay Capsule Generation</h3>
                <div id="capsuleStatus" class="status info">‚ö° Ready to generate replay capsules...</div>
                <button onclick="generateSingleCapsule()">Generate Single Capsule</button>
                <button onclick="generateTestCapsule()">Generate Test Capsule</button>
                <div id="capsuleDisplay"></div>
            </div>

            <!-- Multi-Format Verification -->
            <div class="test-section">
                <h3>Multi-Format Output Verification</h3>
                <div id="formatStatus" class="status info">üé¨ Multi-format verification ready...</div>
                <button onclick="testMultiFormatGeneration()">Test All Formats</button>
                <div id="formatDisplay"></div>
            </div>

            <!-- Vault Feed Integration -->
            <div class="test-section">
                <h3>ChaosKey333 Vault Feed</h3>
                <div id="feedStatus" class="status info">üåä Vault feed integration ready...</div>
                <button onclick="testVaultFeed()">Test Feed Integration</button>
                <button onclick="getRecentCapsules()">Get Recent Capsules</button>
                <div id="feedDisplay" class="feed-display"></div>
            </div>

            <!-- Automatic Scheduling -->
            <div class="test-section">
                <h3>Broadcast Pulse Scheduler</h3>
                <div id="schedulerStatus" class="status info">‚è∞ Automatic scheduling ready...</div>
                <div class="auto-controls">
                    <input type="number" id="intervalInput" class="interval-input" value="15" placeholder="15">
                    <span>seconds</span>
                    <button onclick="startAutoGeneration()">Start Auto</button>
                    <button onclick="stopAutoGeneration()">Stop Auto</button>
                </div>
                <div id="autoStatus"></div>
            </div>

            <!-- Real-Time Feed Monitor -->
            <div class="test-section">
                <h3>Real-Time Keyholder Feed</h3>
                <div id="realtimeStatus" class="status info">üì° Real-time monitoring ready...</div>
                <button onclick="startRealtimeMonitoring()">Start Monitoring</button>
                <button onclick="stopRealtimeMonitoring()">Stop Monitoring</button>
                <div id="realtimeDisplay" class="feed-display"></div>
            </div>

            <!-- Complete Integration Test -->
            <div class="test-section master-control">
                <h3>Complete Integration Test</h3>
                <div id="integrationStatus" class="status info">üîÆ Ready for complete integration test...</div>
                <button onclick="runCompleteIntegrationTest()">üöÄ RUN COMPLETE TEST üöÄ</button>
            </div>
        </div>
    </div>

    <script>
        let terminalInitialized = false;
        let realtimeMonitoring = false;
        let realtimeInterval = null;
        let feedSubscriptionActive = false;

        // Initialize Terminal
        async function initializeTerminal() {
            const status = document.getElementById('initStatus');
            status.className = 'status loading';
            status.innerHTML = 'üåå Initializing Cosmic Replay Terminal v2.0...';

            try {
                const response = await fetch('/api/cosmic-terminal/initialize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    terminalInitialized = true;
                    status.className = 'status success';
                    status.innerHTML = `‚úÖ ${result.message}

üîÆ Terminal Status:
- Operational: ${result.status.operational}
- Components: ${Object.keys(result.status.components).join(', ')}
- Pre-generation hooks: ${result.status.hooks.preGeneration}
- Post-generation hooks: ${result.status.hooks.postGeneration}
- Error hooks: ${result.status.hooks.onError}

üåå Cosmic Replay Terminal v2.0 is LIVE!`;
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                status.className = 'status error';
                status.innerHTML = `‚ùå Initialization Failed: ${error.message}`;
            }
        }

        // Get Terminal Status
        async function getTerminalStatus() {
            try {
                const response = await fetch('/api/cosmic-terminal/status');
                const result = await response.json();
                
                const status = document.getElementById('initStatus');
                if (result.initialized) {
                    status.className = 'status success';
                    status.innerHTML = `‚úÖ Terminal Status: OPERATIONAL

üìä Component Status:
${Object.entries(result.status.components).map(([key, value]) => 
    `- ${key}: ${Array.isArray(value) ? value.join(', ') : value}`
).join('\n')}

üîó Hooks Active:
- Pre-generation: ${result.status.hooks.preGeneration}
- Post-generation: ${result.status.hooks.postGeneration}
- Error: ${result.status.hooks.onError}`;
                } else {
                    status.className = 'status warning';
                    status.innerHTML = '‚ö†Ô∏è Terminal not initialized. Click "Initialize Terminal" first.';
                }
            } catch (error) {
                const status = document.getElementById('initStatus');
                status.className = 'status error';
                status.innerHTML = `‚ùå Status check failed: ${error.message}`;
            }
        }

        // Test Hooks Operational
        async function testHooksOperational() {
            if (!terminalInitialized) {
                alert('‚ö†Ô∏è Initialize terminal first');
                return;
            }
            
            const status = document.getElementById('initStatus');
            const originalContent = status.innerHTML;
            
            status.className = 'status loading';
            status.innerHTML = 'üîÑ Testing hooks operational status...';
            
            // Generate a test capsule to trigger hooks
            try {
                const response = await fetch('/api/cosmic-terminal/generate-capsule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ hookTest: true })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    status.className = 'status success';
                    status.innerHTML = `${originalContent}

üî• Hook Test: PASSED
‚ú® Pre/Post generation hooks triggered successfully
üì° Capsule ${result.capsule.pulseId} generated with hooks`;
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                status.className = 'status warning';
                status.innerHTML = `${originalContent}

‚ö†Ô∏è Hook test failed: ${error.message}`;
            }
        }

        // Generate Single Capsule
        async function generateSingleCapsule() {
            if (!terminalInitialized) {
                alert('‚ö†Ô∏è Initialize terminal first');
                return;
            }

            const status = document.getElementById('capsuleStatus');
            status.className = 'status loading';
            status.innerHTML = 'üîÆ Generating replay capsule...';

            try {
                const response = await fetch('/api/cosmic-terminal/generate-capsule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        source: 'manual',
                        priority: 'high' 
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    status.className = 'status success';
                    status.innerHTML = `‚úÖ ${result.message}

üì° Pulse ID: ${result.capsule.pulseId}
‚è∞ Generated: ${new Date(result.capsule.timestamp).toLocaleString()}
üåå Cosmic Energy: ${result.capsule.vaultStateSnapshot.cosmicEnergy.toFixed(2)}
üë• Active Keyholders: ${result.capsule.vaultStateSnapshot.keyholders}
üìà Total Relics: ${result.capsule.vaultStateSnapshot.totalRelics}`;

                    displayCapsuleDetails(result.capsule);
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                status.className = 'status error';
                status.innerHTML = `‚ùå Capsule generation failed: ${error.message}`;
            }
        }

        // Generate Test Capsule
        async function generateTestCapsule() {
            if (!terminalInitialized) {
                alert('‚ö†Ô∏è Initialize terminal first');
                return;
            }

            const status = document.getElementById('capsuleStatus');
            status.className = 'status loading';
            status.innerHTML = 'üß™ Generating test replay capsule...';

            try {
                const response = await fetch('/api/cosmic-terminal/generate-capsule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        test: true,
                        testMode: 'full-verification' 
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    status.className = 'status success';
                    status.innerHTML = `‚úÖ Test capsule generated successfully!

üß™ Test Pulse ID: ${result.capsule.pulseId}
üé¨ Formats Generated: ${Object.keys(result.capsule.formats).length}
‚úÖ All Formats Valid: ${Object.values(result.capsule.verificationResults).every(r => r.valid)}`;

                    displayCapsuleDetails(result.capsule);
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                status.className = 'status error';
                status.innerHTML = `‚ùå Test generation failed: ${error.message}`;
            }
        }

        // Display Capsule Details
        function displayCapsuleDetails(capsule) {
            const display = document.getElementById('capsuleDisplay');
            
            const formatVerifications = Object.entries(capsule.verificationResults)
                .map(([format, result]) => 
                    `<div class="format-box ${result.valid ? 'valid' : 'invalid'}">
                        <strong>${format.toUpperCase()}</strong>
                        <br>${result.valid ? '‚úÖ Valid' : '‚ùå Invalid'}
                        ${result.error ? `<br>Error: ${result.error}` : ''}
                    </div>`
                ).join('');

            display.innerHTML = `
                <div class="capsule-display">
                    <h4>üîÆ Capsule Details</h4>
                    <div><strong>Pulse ID:</strong> <span class="pulse-id">${capsule.pulseId}</span></div>
                    <div><strong>Cosmic Energy:</strong> <span class="cosmic-energy">${capsule.vaultStateSnapshot.cosmicEnergy.toFixed(2)}</span></div>
                    <div><strong>Timestamp:</strong> ${new Date(capsule.timestamp).toLocaleString()}</div>
                    <div><strong>Terminal Version:</strong> ${capsule.terminalVersion}</div>
                    
                    <h4>üé¨ Format Verification</h4>
                    <div class="format-verification">
                        ${formatVerifications}
                    </div>
                </div>
            `;
        }

        // Test Multi-Format Generation
        async function testMultiFormatGeneration() {
            const status = document.getElementById('formatStatus');
            status.className = 'status loading';
            status.innerHTML = 'üé¨ Testing multi-format output generation...';

            try {
                // Generate a capsule and check formats
                const response = await fetch('/api/cosmic-terminal/generate-capsule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ formatTest: true })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const formats = result.capsule.formats;
                    const verifications = result.capsule.verificationResults;
                    
                    let formatDetails = 'üé¨ Multi-Format Test Results:\n\n';
                    
                    // Check each format
                    if (formats.mp4_4k) {
                        formatDetails += `‚úÖ 4K MP4: ${verifications.mp4_4k.valid ? 'VALID' : 'INVALID'}\n`;
                        formatDetails += `  Resolution: ${formats.mp4_4k.resolution}\n`;
                        formatDetails += `  Size: ${formats.mp4_4k.fileSize}MB\n\n`;
                    }
                    
                    if (formats.webm) {
                        formatDetails += `‚úÖ WebM: ${verifications.webm.valid ? 'VALID' : 'INVALID'}\n`;
                        formatDetails += `  Codec: ${formats.webm.codec}\n`;
                        formatDetails += `  Size: ${formats.webm.fileSize}MB\n\n`;
                    }
                    
                    if (formats.nft_metadata) {
                        formatDetails += `‚úÖ NFT Metadata: ${verifications.nft_metadata.valid ? 'VALID' : 'INVALID'}\n`;
                        formatDetails += `  Standard: ${formats.nft_metadata.standard}\n`;
                        formatDetails += `  Attributes: ${formats.nft_metadata.attributes.length}\n`;
                    }

                    status.className = 'status success';
                    status.innerHTML = formatDetails;
                    
                    displayFormatDetails(formats, verifications);
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                status.className = 'status error';
                status.innerHTML = `‚ùå Multi-format test failed: ${error.message}`;
            }
        }

        // Display Format Details
        function displayFormatDetails(formats, verifications) {
            const display = document.getElementById('formatDisplay');
            
            const formatBoxes = Object.entries(formats).map(([format, data]) => {
                const verification = verifications[format];
                return `
                    <div class="format-box ${verification.valid ? 'valid' : 'invalid'}">
                        <strong>${format.replace('_', ' ').toUpperCase()}</strong>
                        <br>${verification.valid ? '‚úÖ Valid' : '‚ùå Invalid'}
                        <br>Size: ${data.fileSize}MB
                        ${data.resolution ? `<br>Res: ${data.resolution}` : ''}
                        ${data.codec ? `<br>Codec: ${data.codec}` : ''}
                    </div>
                `;
            }).join('');

            display.innerHTML = `
                <div class="format-verification">
                    ${formatBoxes}
                </div>
            `;
        }

        // Test Vault Feed
        async function testVaultFeed() {
            const status = document.getElementById('feedStatus');
            status.className = 'status loading';
            status.innerHTML = 'üåä Testing vault feed integration...';

            try {
                // Generate a capsule to test feed
                const response = await fetch('/api/cosmic-terminal/generate-capsule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ feedTest: true })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Check if capsule appears in feed
                    const feedResponse = await fetch('/api/cosmic-terminal/recent-capsules?count=5');
                    const feedResult = await feedResponse.json();
                    
                    if (feedResult.success && feedResult.capsules.length > 0) {
                        const latestCapsule = feedResult.capsules[feedResult.capsules.length - 1];
                        
                        status.className = 'status success';
                        status.innerHTML = `‚úÖ Vault feed integration successful!

üì° Capsule pushed to feed: ${result.capsule.pulseId}
üåä Feed contains ${feedResult.capsules.length} capsules
‚ö° Real-time delivery: CONFIRMED
üîë Latest pulse: ${latestCapsule.pulseId}`;

                        displayFeedCapsules(feedResult.capsules);
                    } else {
                        throw new Error('Capsule not found in feed');
                    }
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                status.className = 'status error';
                status.innerHTML = `‚ùå Vault feed test failed: ${error.message}`;
            }
        }

        // Get Recent Capsules
        async function getRecentCapsules() {
            try {
                const response = await fetch('/api/cosmic-terminal/recent-capsules?count=10');
                const result = await response.json();
                
                if (result.success) {
                    const status = document.getElementById('feedStatus');
                    status.className = 'status success';
                    status.innerHTML = `‚úÖ Retrieved ${result.capsules.length} recent capsules from vault feed`;
                    
                    displayFeedCapsules(result.capsules);
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                const status = document.getElementById('feedStatus');
                status.className = 'status error';
                status.innerHTML = `‚ùå Failed to get recent capsules: ${error.message}`;
            }
        }

        // Display Feed Capsules
        function displayFeedCapsules(capsules) {
            const display = document.getElementById('feedDisplay');
            
            if (capsules.length === 0) {
                display.innerHTML = '<div class="feed-item">üì≠ No capsules in feed yet</div>';
                return;
            }

            const feedItems = capsules.slice().reverse().map(capsule => `
                <div class="feed-item">
                    <div><strong>üîÆ ${capsule.pulseId}</strong></div>
                    <div>‚è∞ ${new Date(capsule.timestamp).toLocaleString()}</div>
                    <div>üë• Keyholders: ${capsule.vaultStateSnapshot.keyholders}</div>
                    <div>‚ö° Energy: <span class="cosmic-energy">${capsule.vaultStateSnapshot.cosmicEnergy.toFixed(2)}</span></div>
                    <div>üé¨ Formats: ${Object.keys(capsule.formats).join(', ')}</div>
                </div>
            `).join('');

            display.innerHTML = feedItems;
        }

        // Start Auto Generation
        async function startAutoGeneration() {
            const interval = parseInt(document.getElementById('intervalInput').value) || 15;
            const intervalMs = interval * 1000;

            try {
                const response = await fetch('/api/cosmic-terminal/schedule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        action: 'start', 
                        intervalMs: intervalMs 
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const status = document.getElementById('schedulerStatus');
                    status.className = 'status success';
                    status.innerHTML = `‚úÖ ${result.message}

‚è∞ Auto-generation active every ${interval} seconds
üì° Vault Broadcast Pulse Scheduler: OPERATIONAL`;

                    // Update auto status display
                    document.getElementById('autoStatus').innerHTML = `
                        <div class="status success">
                            üîÑ Auto-generation running every ${interval}s
                            <div class="real-time-indicator"></div>
                        </div>
                    `;
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                const status = document.getElementById('schedulerStatus');
                status.className = 'status error';
                status.innerHTML = `‚ùå Failed to start auto-generation: ${error.message}`;
            }
        }

        // Stop Auto Generation
        async function stopAutoGeneration() {
            try {
                const response = await fetch('/api/cosmic-terminal/schedule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'stop' })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const status = document.getElementById('schedulerStatus');
                    status.className = 'status info';
                    status.innerHTML = `‚úÖ ${result.message}

‚èπÔ∏è Automatic generation stopped
üì° Vault Broadcast Pulse Scheduler: STANDBY`;

                    document.getElementById('autoStatus').innerHTML = '';
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                const status = document.getElementById('schedulerStatus');
                status.className = 'status error';
                status.innerHTML = `‚ùå Failed to stop auto-generation: ${error.message}`;
            }
        }

        // Start Real-time Monitoring
        function startRealtimeMonitoring() {
            if (realtimeMonitoring) {
                alert('‚ö†Ô∏è Real-time monitoring already active');
                return;
            }

            realtimeMonitoring = true;
            const status = document.getElementById('realtimeStatus');
            status.className = 'status success';
            status.innerHTML = 'üì° Real-time monitoring ACTIVE - Watching for new capsules...';

            // Poll for new capsules every 3 seconds
            realtimeInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/cosmic-terminal/recent-capsules?count=3');
                    const result = await response.json();
                    
                    if (result.success && result.capsules.length > 0) {
                        displayRealtimeFeed(result.capsules);
                    }
                } catch (error) {
                    console.error('Real-time monitoring error:', error);
                }
            }, 3000);

            document.getElementById('realtimeDisplay').innerHTML = `
                <div class="feed-item">
                    <div class="real-time-indicator"></div>
                    <strong>üì° Real-time monitoring active</strong>
                    <div>Watching for new capsules for ChaosKey333 keyholders...</div>
                </div>
            `;
        }

        // Stop Real-time Monitoring
        function stopRealtimeMonitoring() {
            if (!realtimeMonitoring) {
                alert('‚ö†Ô∏è Real-time monitoring not active');
                return;
            }

            realtimeMonitoring = false;
            clearInterval(realtimeInterval);
            
            const status = document.getElementById('realtimeStatus');
            status.className = 'status info';
            status.innerHTML = 'üì° Real-time monitoring stopped';

            document.getElementById('realtimeDisplay').innerHTML = `
                <div class="feed-item">
                    <strong>üì° Real-time monitoring stopped</strong>
                    <div>Click "Start Monitoring" to resume watching for new capsules</div>
                </div>
            `;
        }

        // Display Real-time Feed
        function displayRealtimeFeed(capsules) {
            const display = document.getElementById('realtimeDisplay');
            
            const now = Date.now();
            const recentCapsules = capsules.filter(capsule => 
                now - capsule.timestamp < 60000 // Within last minute
            );

            const feedItems = recentCapsules.map(capsule => `
                <div class="feed-item" style="border-left: 3px solid #00ff00;">
                    <div class="real-time-indicator"></div>
                    <strong>üîÆ NEW: ${capsule.pulseId}</strong>
                    <div>‚ö° Energy: <span class="cosmic-energy">${capsule.vaultStateSnapshot.cosmicEnergy.toFixed(2)}</span></div>
                    <div>üì° Delivered to ${capsule.vaultStateSnapshot.keyholders} keyholders</div>
                    <div>‚è∞ ${new Date(capsule.timestamp).toLocaleTimeString()}</div>
                </div>
            `).join('');

            if (feedItems) {
                display.innerHTML = feedItems;
            }
        }

        // Run Complete Integration Test
        async function runCompleteIntegrationTest() {
            const status = document.getElementById('integrationStatus');
            status.className = 'status loading';
            status.innerHTML = 'üöÄ Running complete integration test...';

            try {
                const response = await fetch('/api/cosmic-terminal/test-integration', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                let resultText = 'üß™ Complete Integration Test Results:\n\n';
                
                const tests = [
                    { key: 'initialization', name: 'Terminal Initialization' },
                    { key: 'capsuleGeneration', name: 'Replay Capsule Generation' },
                    { key: 'multiFormat', name: 'Multi-Format Output (4K MP4, WebM, NFT)' },
                    { key: 'vaultFeed', name: 'Vault Feed Real-time Push' },
                    { key: 'hooks', name: 'Hook System Operational' }
                ];

                tests.forEach(test => {
                    const passed = result.testResults[test.key];
                    resultText += `${passed ? '‚úÖ' : '‚ùå'} ${test.name}: ${passed ? 'PASSED' : 'FAILED'}\n`;
                });

                resultText += `\nüéØ Overall Result: ${result.success ? 'ALL TESTS PASSED!' : 'SOME TESTS FAILED'}\n`;
                resultText += `üìä Terminal Status: ${result.status ? 'OPERATIONAL' : 'NOT READY'}`;

                if (result.success) {
                    status.className = 'status success';
                    resultText += '\n\nüéâ Cosmic Replay Terminal v2.0 is fully operational!';
                    resultText += '\nüì° Hooks are live and operational';
                    resultText += '\nüåä Vault feed delivering capsules in near real-time';
                    resultText += '\nüé¨ Multi-format output verified (4K MP4, WebM, NFT-metadata-ready)';
                    
                    terminalInitialized = true;
                } else {
                    status.className = 'status error';
                    resultText += '\n\n‚ö†Ô∏è Some components need attention - check individual test results';
                }

                status.innerHTML = resultText;

            } catch (error) {
                status.className = 'status error';
                status.innerHTML = `‚ùå Integration test failed: ${error.message}`;
            }
        }

        // Auto-initialize on page load
        window.onload = async function() {
            await new Promise(resolve => setTimeout(resolve, 1500));
            console.log('üåå Cosmic Replay Terminal v2.0 Test Environment loaded');
            
            // Check if terminal is already initialized
            await getTerminalStatus();
        };
    </script>
</body>
</html>